# parse_scad_for_modules.py
import re
import os

class ModuleMeta:
    def __init__(self, name, synopsis="", description="", usage="", arguments=None):
        self.name = name
        self.synopsis = synopsis
        self.description = description
        self.usage = usage
        self.arguments = arguments or []

class SCADFileMeta:
    def __init__(self, filename):
        self.filename = filename
        self.includes = []          # include <xxx> statements in file body
        self.header_includes = []   # include <xxx> statements from header comments
        self.summary = ""
        self.modules = []

def parse_scad_for_modules(filepath):
    meta = SCADFileMeta(filename=os.path.basename(filepath))
    current_module = None
    in_header = True

    include_re = re.compile(r'^\s*include\s*<([^>]+)>', re.IGNORECASE)
    module_re = re.compile(r'^\s*module\s+(\w+)\s*\((.*)\)')
    synopsis_re = re.compile(r'^\s*//\s*Synopsis:\s*(.*)')
    description_re = re.compile(r'^\s*//\s*Description:\s*(.*)')
    argument_re = re.compile(r'^\s*//\s*(\w+)\s*=\s*(.*?)(?:\(Default:\s*(.*?)\))?$')

    with open(filepath, "r") as f:
        for line in f:
            line = line.rstrip()

            # Header includes
            if in_header and line.startswith("//"):
                m_inc = re.match(r'^\s*//\s*Includes:\s*', line)
                if m_inc:
                    # collect following comment lines starting with "//   include <...>"
                    for hline in f:
                        hline = hline.strip()
                        if not hline.startswith("//"):
                            break
                        hline_content = hline.lstrip("/ ").strip()
                        if hline_content.lower().startswith("include"):
                            meta.header_includes.append(hline_content)
                continue

            if not line.startswith("//"):
                in_header = False

            # includes in body
            m_inc = include_re.match(line)
            if m_inc:
                meta.includes.append(m_inc.group(1))

            # module definitions
            m_mod = module_re.match(line)
            if m_mod:
                current_module = ModuleMeta(name=m_mod.group(1))
                meta.modules.append(current_module)

            m_syn = synopsis_re.match(line)
            if m_syn and current_module:
                current_module.synopsis = m_syn.group(1).strip()

            m_desc = description_re.match(line)
            if m_desc and current_module:
                current_module.description = m_desc.group(1).strip()

            m_arg = argument_re.match(line)
            if m_arg and current_module:
                arg_name = m_arg.group(1)
                arg_default = m_arg.group(3) if m_arg.group(3) else None
                current_module.arguments.append({
                    "name": arg_name,
                    "default": arg_default,
                    "description": m_arg.group(2).strip()
                })

    return meta

