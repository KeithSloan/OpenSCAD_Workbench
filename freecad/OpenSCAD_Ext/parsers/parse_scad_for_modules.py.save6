import re
from collections import namedtuple

# Simple container classes for meta
ModuleMeta = namedtuple("ModuleMeta", ["name", "synopsis", "description", "usage", "arguments"])
ArgumentMeta = namedtuple("ArgumentMeta", ["name", "default", "description"])
SCADMeta = namedtuple("SCADMeta", ["filename", "header_includes", "includes", "modules"])


def parse_scad_for_modules(filename):
    """
    Parse a SCAD file for documented modules and includes.

    Returns a SCADMeta object.
    """
    with open(filename, "r") as f:
        lines = f.readlines()

    header_includes = []
    includes = []
    modules = []

    current_module = None
    module_lines = []
    in_header = True
    in_module_comment = False
    module_comment_lines = []

    for line in lines:
        stripped = line.strip()

        # Header includes
        if in_header and stripped.startswith("// Includes:"):
            in_header = False  # only parse once
            # collect subsequent lines starting with "//   include"
            idx = lines.index(line)
            while idx + 1 < len(lines):
                idx += 1
                next_line = lines[idx].strip()
                m = re.match(r"//\s+include\s+<(.+)>", next_line)
                if m:
                    header_includes.append(m.group(1))
                else:
                    break

        # Regular includes
        m_inc = re.match(r"include\s+<(.+)>", stripped)
        if m_inc:
            includes.append(m_inc.group(1))

        # Module comment start
        if stripped.startswith("// Module:"):
            if current_module:  # save previous
                modules.append(_build_module(current_module, module_comment_lines))
                module_comment_lines = []
            current_module = stripped[len("// Module:"):].strip()
            in_module_comment = True
            continue

        if in_module_comment:
            if stripped.startswith("//") or stripped == "":
                module_comment_lines.append(stripped)
            else:
                # end of comment block
                modules.append(_build_module(current_module, module_comment_lines))
                current_module = None
                module_comment_lines = []
                in_module_comment = False

    # catch last module
    if current_module:
        modules.append(_build_module(current_module, module_comment_lines))

    return SCADMeta(
        filename=filename.split("/")[-1],
        header_includes=header_includes,
        includes=includes,
        modules=modules,
    )


def _build_module(name, comment_lines):
    """
    Build a ModuleMeta from comment lines.
    """
    synopsis = ""
    description = ""
    usage = ""
    arguments = []

    arg_section = False

    for line in comment_lines:
        line = line.lstrip("//").strip()
        if line.startswith("Synopsis:"):
            synopsis = line[len("Synopsis:"):].strip()
        elif line.startswith("Description:"):
            description = line[len("Description:"):].strip()
        elif line.startswith("Usage:"):
            usage = line[len("Usage:"):].strip()
        elif line.startswith("Arguments:"):
            arg_section = True
            continue
        elif arg_section:
            if line.startswith("---") or line == "":
                arg_section = False
            else:
                # parse argument line: name = description (Default: xxx)
                m_arg = re.match(r"(\w+)\s*=\s*.*?(\(Default: ([^)]+)\))?", line)
                if m_arg:
                    arg_name = m_arg.group(1)
                    default = m_arg.group(3) if m_arg.group(3) else None
                    description_text = line
                    arguments.append(ArgumentMeta(name=arg_name, default=default, description=description_text))
                else:
                    # fallback: treat entire line as description with empty name
                    arguments.append(ArgumentMeta(name=line, default=None, description=line))

    return ModuleMeta(name=name, synopsis=synopsis, description=description, usage=usage, arguments=arguments)

