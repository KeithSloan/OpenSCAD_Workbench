# -*- coding: utf8 -*-
#***************************************************************************
#* AST Processing for OpenSCAD CSG importer                               *
#* Converts AST nodes to FreeCAD Shapes or SCAD strings with fallbacks    *
#***************************************************************************

import os
import subprocess
import tempfile
import FreeCAD
import Part
import Mesh
from freecad.OpenSCAD_Ext.logger.Workbench_logger import write_log
from freecad.OpenSCAD_Ext.parsers.csg_parser.ast_helpers import get_tess, apply_transform

BaseError = FreeCAD.Base.FreeCADError

class OpenSCADError(BaseError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# -----------------------------
# OpenSCAD fallback helpers
# -----------------------------

def generate_stl_from_scad(scad_str, check_syntax=False, timeout=60):
    write_log("AST", f"generate stl from scad {scad_str}")
    tmpdir = tempfile.mkdtemp()
    scad_file = os.path.join(tmpdir, "fallback.scad")
    stl_file = os.path.join(tmpdir, "fallback.stl")
    prefs = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Mod/OpenSCAD")
    openscad_exe = prefs.GetString('openscadexecutable', "")
    if not openscad_exe or not os.path.isfile(openscad_exe):
        raise FileNotFoundError(
            "OpenSCAD executable not found. Set 'openscadexecutable' under Preferences → OpenSCAD."
        )
    with open(scad_file, "w") as f:
        f.write(scad_str)
    cmd = [openscad_exe, "-o", stl_file, scad_file]
    if check_syntax:
        cmd.append("-q")
    try:
        subprocess.run(cmd, check=True, capture_output=True, timeout=timeout)
    except subprocess.TimeoutExpired:
        os.remove(scad_file)
        raise OpenSCADError(f"OpenSCAD call timed out after {timeout} seconds")
    except subprocess.CalledProcessError as e:
        os.remove(scad_file)
        raise OpenSCADError(e.stderr.decode())
    os.remove(scad_file)
    write_log("AST_Hull:Minkowski", f"Calling OpenSCAD CLI for fallback STL: {stl_file}")
    return stl_file

def stl_to_shape(stl_path, tolerance=0.05):
    write_log("AST_Hull:Minkowski", f"Importing STL and converting to Part.Shape: {stl_path}")
    mesh_obj = Mesh.Mesh(stl_path)
    shape = Part.Shape()
    shape.makeShapeFromMesh(mesh_obj.Topology, tolerance)
    write_log("AST", f"stl to Shape {shape}")
    return shape

def fallback_to_OpenSCAD(node, operation_type="Hull"):
    write_log(operation_type, f"{operation_type} could not be processed natively — fallback to OpenSCAD")
    scad_str = flatten_ast_node(node, indent=4)
    stl_file = generate_stl_from_scad(scad_str)
    shape = stl_to_shape(stl_file)
    write_log("AST", f"OpenSCAD returned Shape {shape}")
    return shape

# -----------------------------
# AST processing
# -----------------------------

def process_AST(nodes, mode="multiple"):
    shapes = []
    if not isinstance(nodes, list):
        nodes = [nodes]
    for node in nodes:
        s = process_AST_node(node)
        if s is None:
            continue
        elif isinstance(s, (list, tuple)):
            shapes.extend(s)
        else:
            shapes.append(s)
        write_log("AST", f"process AST Node {getattr(node,'node_type',str(type(node)))} returned Shape {s}")
    if mode == "single" and shapes:
        return shapes[0]
    return shapes

def process_AST_node(node):
    # Dispatch by type
    node_type = type(node).__name__
    if node_type in ["Hull", "Minkowski"]:
        if node_type == "Hull":
            return process_hull(node)
        else:
            return process_minkowski(node)

    elif node_type == "Group":
        # Process children and return as list of shapes
        shapes = [process_AST_node(child) for child in getattr(node, "children", [])]
        # Flatten nested lists
        flat_shapes = []
        for s in shapes:
            if isinstance(s, (list, tuple)):
                flat_shapes.extend(s)
            elif s is not None:
                flat_shapes.append(s)
        return flat_shapes

    elif node_type in ["Sphere", "Cube", "Cylinder", "Circle"]:
        return create_primitive(node)

    elif node_type in ["MultMatrix", "Translate", "Rotate", "Scale"]:
        # Need a base shape to apply transform to; usually children
        base_shapes = []
        for child in getattr(node, "children", []):
            s = process_AST_node(child)
            if s is not None:
                base_shapes.append(s)
        if not base_shapes:
            # fallback shape for transform
            s = Part.makeBox(1,1,1)
            return apply_transform(s, node)
        elif len(base_shapes) == 1:
            return apply_transform(base_shapes[0], node)
        else:
            # union all children first
            union_shape = base_shapes[0].copy()
            for s in base_shapes[1:]:
                union_shape = union_shape.fuse(s)
            return apply_transform(union_shape, node)
    
    elif node_type in ["Union", "Difference", "Intersection"]:
        return create_boolean(node)

    else:
        write_log("AST", f"Unknown node type {node_type}, falling back to OpenSCAD")
        return fallback_to_OpenSCAD(node, node_type)

# -----------------------------
# Hull / Minkowski
# -----------------------------

def try_hull(node):
    return None
def process_hull(node):
    hull_shape = try_hull(node)
    if hull_shape:
        return hull_shape
    return fallback_to_OpenSCAD(node, "Hull")

def try_minkowski(node):
    return None
def process_minkowski(node):
    mink_shape = try_minkowski(node)
    if mink_shape:
        return mink_shape
    return fallback_to_OpenSCAD(node, "Minkowski")

# -----------------------------
# Boolean operations
# -----------------------------

def create_boolean(node):
    shapes = []
    for child in getattr(node, "children", []):
        s = process_AST_node(child)
        if s is not None:
            shapes.append(s)
    if isinstance(node, list):
        return shapes
    return shapes

# -----------------------------
# Primitive creation
# -----------------------------

def to_vec3(s):
    if isinstance(s, (int,float)):
        return [s,s,s]
    if isinstance(s, (list,tuple)) and len(s) == 3:
        return list(s)
    raise TypeError("Expected scalar or list/tuple of length 3")

def to_tuple3(s):
    if isinstance(s, (int,float)):
        return (s,s,s)
    if isinstance(s, (list,tuple)) and len(s) == 3:
        return tuple(s)
    raise TypeError("Expected scalar or 3-element list/tuple")

def create_primitive(node):
    node_type = type(node).__name__
    params = getattr(node, "params", {})

    if node_type == "Sphere":
        r = params.get("r", 1.0)
        return Part.makeSphere(r)

    elif node_type == "Cube":
        size = params.get("size", [1.0, 1.0, 1.0])
        size = to_tuple3(size)
        return Part.makeBox(*size)

    elif node_type == "Cylinder":
        h = params.get("h", 1.0)
        r1 = params.get("r1", params.get("r", 1.0))
        r2 = params.get("r2", params.get("r", r1))
        center = params.get("center", False)
        # Use tapered cylinder if r1 != r2
        if r1 == r2:
            return Part.makeCylinder(r1, h, FreeCAD.Vector(0,0,0), FreeCAD.Vector(0,0,1), center)
        else:
            return Part.makeCone(r1, r2, h, FreeCAD.Vector(0,0,0), FreeCAD.Vector(0,0,1), center)

    elif node_type == "Circle":
        r = params.get("r", 1.0)
        return Part.makeCircle(r)

    else:
        return None

# -----------------------------
# Flatten AST to SCAD string for fallback
# -----------------------------

def flatten_ast_node(node, indent=0):
    ind = " " * indent
    code = ""
    t = getattr(node, "node_type", None)
    params = getattr(node, "params", {})
    children = getattr(node, "children", [])

    if t in ["hull", "Hull"]:
        code += f"{ind}hull() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif node.node_type == "group":
        # Flatten group by recursively processing children
        for child in getattr(node, "children", []):
            code += flatten_ast_node(child, indent)

    elif t in ["minkowski", "Minkowski"]:
        code += f"{ind}minkowski() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["cube", "Cube"]:
        size = params.get("size", [1,1,1])
        center = str(params.get("center", False)).lower()
        code += f"{ind}cube(size={size}, center={center});\n"

    elif t in ["sphere", "Sphere"]:
        r = params.get("r", 1.0)
        code += f"{ind}sphere(r={r});\n"

    elif t in ["cylinder", "Cylinder"]:
        h = params.get("h", 1.0)
        r1 = params.get("r1", params.get("r", 1.0))
        r2 = params.get("r2", params.get("r", r1))
        center = str(params.get("center", False)).lower()
        code += f"{ind}cylinder(h={h}, r1={r1}, r2={r2}, center={center});\n"

    elif t in ["multmatrix", "MultMatrix"]:
        m = params.get("matrix", [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])
        code += f"{ind}multmatrix({m}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["translate", "Translate"]:
        v = params.get("v", params.get("vector", [0,0,0]))
        code += f"{ind}translate({v}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["rotate", "Rotate"]:
        angle = params.get("a", params.get("angle", 0))
        axis = params.get("v", params.get("vector", [0,0,1]))
        code += f"{ind}rotate(a={angle}, v={axis}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["scale", "Scale"]:
        v = params.get("v", params.get("vector", [1,1,1]))
        code += f"{ind}scale({v}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["union", "Union"]:
        code += f"{ind}union() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["difference", "Difference"]:
        code += f"{ind}difference() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["intersection", "Intersection"]:
        code += f"{ind}intersection() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    else:
        write_log("flatten_ast_node", f"Unhandled node type: {t} — subtree may be lost")

    return code

