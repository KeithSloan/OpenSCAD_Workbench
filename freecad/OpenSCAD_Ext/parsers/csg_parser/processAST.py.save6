# -*- coding: utf8 -*-
#***************************************************************************
#* AST Processing for OpenSCAD CSG importer                               *
#* Converts AST nodes to FreeCAD Shapes or SCAD strings with fallbacks    *
#***************************************************************************

import os
import subprocess
import tempfile
import FreeCAD
import Part
import Mesh
from freecad.OpenSCAD_Ext.logger.Workbench_logger import write_log
from freecad.OpenSCAD_Ext.parsers.csg_parser.ast_helpers import get_tess, apply_transform

BaseError = FreeCAD.Base.FreeCADError

class OpenSCADError(BaseError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

# -----------------------------
# OpenSCAD fallback helpers
# -----------------------------

def generate_stl_from_scad(scad_str, check_syntax=False, timeout=60):
    write_log("AST", f"generate stl from scad {scad_str}")
    tmpdir = tempfile.mkdtemp()
    scad_file = os.path.join(tmpdir, "fallback.scad")
    stl_file = os.path.join(tmpdir, "fallback.stl")
    prefs = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Mod/OpenSCAD")
    openscad_exe = prefs.GetString('openscadexecutable', "")
    if not openscad_exe or not os.path.isfile(openscad_exe):
        raise FileNotFoundError(
            "OpenSCAD executable not found. Set 'openscadexecutable' under Preferences → OpenSCAD."
        )
    with open(scad_file, "w") as f:
        f.write(scad_str)
    cmd = [openscad_exe, "-o", stl_file, scad_file]
    if check_syntax:
        cmd.append("-q")
    try:
        subprocess.run(cmd, check=True, capture_output=True, timeout=timeout)
    except subprocess.TimeoutExpired:
        os.remove(scad_file)
        raise OpenSCADError(f"OpenSCAD call timed out after {timeout} seconds")
    except subprocess.CalledProcessError as e:
        os.remove(scad_file)
        raise OpenSCADError(e.stderr.decode())
    os.remove(scad_file)
    write_log("AST_Hull:Minkowski", f"Calling OpenSCAD CLI for fallback STL: {stl_file}")
    return stl_file

def stl_to_shape(stl_path, tolerance=0.05):
    write_log("AST_Hull:Minkowski", f"Importing STL and converting to Part.Shape: {stl_path}")
    mesh_obj = Mesh.Mesh(stl_path)
    shape = Part.Shape()
    shape.makeShapeFromMesh(mesh_obj.Topology, tolerance)
    write_log("AST", f"stl to Shape {shape}")
    return shape

def fallback_to_OpenSCAD(node, operation_type="Hull"):
    write_log(operation_type, f"{operation_type} could not be processed natively — fallback to OpenSCAD")
    scad_str = flatten_ast_node(node, indent=4)
    stl_file = generate_stl_from_scad(scad_str)
    shape = stl_to_shape(stl_file)
    write_log("AST", f"OpenSCAD returned Shape {shape}")
    return shape

# -----------------------------
# AST processing
# -----------------------------

def process_AST(nodes, mode="multiple"):
    shapes = []
    if not isinstance(nodes, list):
        nodes = [nodes]
    for node in nodes:
        s = process_AST_node(node)
        if s is None:
            continue
        elif isinstance(s, (list, tuple)):
            shapes.extend(s)
        else:
            shapes.append(s)
        write_log("AST", f"process AST Node {getattr(node,'node_type',str(type(node)))} returned Shape {s}")
    if mode == "single" and shapes:
        return shapes[0]
    return shapes

# -----------------------------
# Instrumentation helpers
# -----------------------------

def safe_vector(v, default):
    """Ensure vector is valid; replace None with defaults"""
    if isinstance(v, (int,float)):
        return [v,v,v]
    if isinstance(v, (list,tuple)):
        return [vi if vi is not None else default[i] for i,vi in enumerate(v)]
    return default

# -----------------------------
# AST Node processing
# -----------------------------

def process_AST_node(node):
    node_type = type(node).__name__
    params = getattr(node, "params", {})
    children = getattr(node, "children", [])

    write_log("AST", f"Entering process_AST_node: {node_type}, params={params}, children={len(children)}")

    # Primitive nodes
    if node_type in ["Sphere", "Cube", "Cylinder", "Circle"]:
        for k,v in params.items():
            if v is None:
                write_log("AST_WARNING", f"Node {node_type} has None parameter: {k}")
        return create_primitive(node)

    # Hull / Minkowski
    elif node_type == "Hull":
        return process_hull(node)
    elif node_type == "Minkowski":
        return process_minkowski(node)

    # Group nodes
    elif node_type == "Group":
        shapes = []
        for child in children:
            s = process_AST_node(child)
            if isinstance(s, (list, tuple)):
                shapes.extend(s)
            elif s is not None:
                shapes.append(s)
        return shapes

    # Boolean nodes
    elif node_type in ["Union", "Difference", "Intersection"]:
        return create_boolean(node)

    # Transform nodes
    elif node_type in ["MultMatrix", "Translate", "Rotate", "Scale"]:
        base_shapes = []
        for child in children:
            s = process_AST_node(child)
            if s is not None:
                base_shapes.append(s)

        if not base_shapes:
            write_log("AST_WARNING", f"{node_type} node has no valid children; using fallback box")
            s = Part.makeBox(1,1,1)
        elif len(base_shapes) == 1:
            s = base_shapes[0]
        else:
            s = base_shapes[0].copy()
            for other in base_shapes[1:]:
                s = s.fuse(other)

        # Sanitize transform params
        if node_type == "Translate":
            v = safe_vector(params.get("v", params.get("vector", [0,0,0])), [0,0,0])
            node.params["v"] = v
            write_log("AST", f"Translate vector sanitized: {v}")
        elif node_type == "Rotate":
            v = safe_vector(params.get("v", params.get("vector", [0,0,1])), [0,0,1])
            a = 0.0 if params.get("a", params.get("angle", 0)) is None else params.get("a", 0)
            node.params["v"] = v
            node.params["a"] = a
            write_log("AST", f"Rotate axis sanitized: {v}, angle: {a}")
        elif node_type == "Scale":
            v = safe_vector(params.get("v", params.get("vector", [1,1,1])), [1,1,1])
            node.params["v"] = v
            write_log("AST", f"Scale vector sanitized: {v}")
        elif node_type == "MultMatrix":
            m = params.get("matrix", [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])
            node.params["matrix"] = [[mi if mi is not None else 0.0 for mi in row] for row in m]
            write_log("AST", f"MultMatrix sanitized: {node.params['matrix']}")

        return apply_transform(s, node)

    # Unknown nodes — fallback
    else:
        write_log("AST", f"Unknown node type {node_type}, falling back to OpenSCAD")
        return fallback_to_OpenSCAD(node, node_type)

# -----------------------------
# Hull / Minkowski
# -----------------------------

def try_hull(node):
    return None
def process_hull(node):
    hull_shape = try_hull(node)
    if hull_shape:
        return hull_shape
    return fallback_to_OpenSCAD(node, "Hull")

def try_minkowski(node):
    return None
def process_minkowski(node):
    mink_shape = try_minkowski(node)
    if mink_shape:
        return mink_shape
    return fallback_to_OpenSCAD(node, "Minkowski")

# -----------------------------
# Boolean operations
# -----------------------------

def create_boolean(node):
    shapes = []
    for child in getattr(node, "children", []):
        s = process_AST_node(child)
        if s is None:
            continue
        if isinstance(s, (list, tuple)):
            shapes.extend(s)
        else:
            shapes.append(s)
    return shapes

# -----------------------------
# Primitive creation
# -----------------------------

def to_vec3(s):
    if isinstance(s, (int,float)):
        return [s,s,s]
    if isinstance(s, (list,tuple)) and len(s) == 3:
        return list(s)
    raise TypeError("Expected scalar or list/tuple of length 3")

def to_tuple3(s):
    if isinstance(s, (int,float)):
        return (s,s,s)
    if isinstance(s, (list,tuple)) and len(s) == 3:
        return tuple(s)
    raise TypeError("Expected scalar or 3-element list/tuple")

def create_primitive(node):
    node_type = type(node).__name__
    params = getattr(node, "params", {})

    if node_type == "Sphere":
        r = 1.0 if params.get("r") is None else params.get("r")
        return Part.makeSphere(r)

    elif node_type == "Cube":
        size = params.get("size", [1.0,1.0,1.0])
        size = [1.0 if x is None else x for x in size]
        size = to_tuple3(size)
        return Part.makeBox(*size)

    elif node_type == "Cylinder":
        h = 1.0 if params.get("h") is None else params.get("h")
        r1 = 1.0 if params.get("r1") is None else params.get("r1")
        r2 = 1.0 if params.get("r2") is None else params.get("r2")
        center = params.get("center", False)
        if r1 == r2:
            return Part.makeCylinder(r1, h, FreeCAD.Vector(0,0,0), FreeCAD.Vector(0,0,1), center)
        else:
            return Part.makeCone(r1, r2, h, FreeCAD.Vector(0,0,0), FreeCAD.Vector(0,0,1), center)

    elif node_type == "Circle":
        r = 1.0 if params.get("r") is None else params.get("r")
        return Part.makeCircle(r)

    return None

# -----------------------------
# Flatten AST to SCAD string for fallback
# -----------------------------

def flatten_ast_node(node, indent=0):
    ind = " " * indent
    code = ""
    t = getattr(node, "node_type", None)
    params = getattr(node, "params", {})
    children = getattr(node, "children", [])

    if t in ["hull", "Hull"]:
        code += f"{ind}hull() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["group"]:
        for c in children:
            code += flatten_ast_node(c, indent)

    elif t in ["minkowski", "Minkowski"]:
        code += f"{ind}minkowski() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["cube", "Cube"]:
        size = [1 if x is None else x for x in params.get("size", [1,1,1])]
        center = str(params.get("center", False)).lower()
        code += f"{ind}cube(size={size}, center={center});\n"

    elif t in ["sphere", "Sphere"]:
        r = 1 if params.get("r") is None else params.get("r")
        code += f"{ind}sphere(r={r});\n"

    elif t in ["cylinder", "Cylinder"]:
        h = 1 if params.get("h") is None else params.get("h")
        r1 = 1 if params.get("r1") is None else params.get("r1")
        r2 = 1 if params.get("r2") is None else params.get("r2")
        center = str(params.get("center", False)).lower()
        code += f"{ind}cylinder(h={h}, r1={r1}, r2={r2}, center={center});\n"

    elif t in ["multmatrix", "MultMatrix"]:
        m = [[0.0 if mi is None else mi for mi in row] for row in params.get("matrix", [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]])]
        code += f"{ind}multmatrix({m}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["translate", "Translate"]:
        v = [0 if vi is None else vi for vi in params.get("v", params.get("vector",[0,0,0]))]
        code += f"{ind}translate({v}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["rotate", "Rotate"]:
        v = [0 if vi is None else vi for vi in params.get("v", params.get("vector",[0,0,1]))]
        a = 0 if params.get("a", params.get("angle",0)) is None else params.get("a", params.get("angle",0))
        code += f"{ind}rotate(a={a}, v={v}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["scale", "Scale"]:
        v = [1 if vi is None else vi for vi in params.get("v", params.get("vector",[1,1,1]))]
        code += f"{ind}scale({v}) {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["union", "Union"]:
        code += f"{ind}union() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["difference", "Difference"]:
        code += f"{ind}difference() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    elif t in ["intersection", "Intersection"]:
        code += f"{ind}intersection() {{\n"
        for c in children:
            code += flatten_ast_node(c, indent+4)
        code += f"{ind}}}\n"

    else:
        write_log("flatten_ast_node", f"Unhandled node type: {t} — subtree may be lost")

    return code
